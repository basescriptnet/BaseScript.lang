#!/usr/bin/env node
// Autogenerated by BaseScript v0.2.71

(function () {if(!globalThis){globalThis=window||global||this||{};}if(globalThis.BS){try{return}finally{}}if(!Array.isArray){Array.isArray=function(arg){returnObject.prototype.toString.call(arg)==='[objectArray]';};}globalThis.BS={placeholder:null,customOperators:{},customTypes:{},libs:[],};BS=globalThis.BS;BS.defineProperty = function (prototype, propertyName, valueCallback, options) {
    options = options || {
        writable: true,
        enumerable: false,
        configurable: true
    };
    options.value = valueCallback;
    Object.defineProperty(prototype, propertyName, options);
}

BS.types = {    RegExp(value) {
        return value instanceof RegExp;
    },
    Array(value) {
        return Array.isArray(value);
    },
    Null(value) {
        return value === null;
    },
    Undefined (value) {
        return value === void 0;
    },
    Int(value) {
        return parseInt(value) === value && !Number.isNaN(value);
    },
    Float(value) {
        return typeof value === 'number' && !Number.isNaN(value);
    },
    Number(value) {
        return typeof value === 'number' && !Number.isNaN(value);
    },
    BigInt(value) {
        return typeof value === 'bigint';
    },
    NaN(value) {
        return Number.isNaN(value);
    },
    String(value) {
        return typeof value === 'string';
    },
    Function(value) {
        return typeof value === 'function';
    },
    Symbol(value) {
        return typeof value === 'symbol';
    },
    Boolean(value) {
        return typeof value === 'boolean';
    },
    Object(value) {
        if (BS.types.HTML && BS.types.HTML(value)) {
            return false;
        }
        if (BS.types.Array(value)) return false;
        return typeof value === 'object' && value !== null;
    },
}
BS.curstomTypes = {Any: () => true};
BS.typeof = function (value) {
    for (let i in this.types) {
        try {
            if (this.types[i](value)) return i;
            //if (this.curstomTypes[i](value)) return i;
        } catch (err) {continue}
    }
}
BS.validateType = function (value, type, nullable) {    // can be simplified. Return instantly.
    // may be issues with arrays[]
    let t = null;
    //debugger;
    if (Array.isArray(type)) {
        for (let i in type) {
            if (type[i].indexOf('[]', '') > -1) {
                if (Array.isArray(value)) {
                    let t = true;
                    for (let j in value) {
                        if (!this.validateType(value[j], type[i].replace('[]', ''))) {
                            t = false;
                            break;
                        }
                    }
                    if (t) return true;
                }
            }
            else if (this.customTypes[type[i].replace('[]', '')]) {
                try {
                    t = this.customTypes[type[i].replace('[]', '')](value);
                } finally { }
            }
            else if (this.types[type[i].replace('[]', '')]) t = this.types[type[i].replace('[]', '')](value);
            if (t) return true;
        }
    } else {
        if (this.customTypes[type]) t = this.customTypes[type](value);
        else if (this.types[type]) t = this.types[type](value);
    }
    if (t || nullable && value === null) return true;
    return false;
}

BS.ifTypeExists = function (type) {
    // may be issues with arrays[]
    if (Array.isArray(type)) {
        for (let i in type) {
            if (this.customTypes[type[i].replace('[]', '')]) continue;
            else if (this.types[type[i].replace('[]', '')]) continue;
            throw new TypeError(`Types ${type[i]} do not exist`);
        }
        return type;
    } else {
        if (this.customTypes[type.replace('[]', '')]) return type;
        if (this.types[type.replace('[]', '')]) return type;
    }
    throw new TypeError(`Type ${type} does not exist`);
}}).call(this);



// Your code below this line

const path_applied = process.cwd(),
    pathLib = require('path'),
    fs = require("fs");
class CLI {
    constructor() {
        this.commands = ['\nOptions:\r', '    -v, --version\t      ' + 'Show version number.' + '\t\t' + '[boolean]\r', '    -w, --watch\t        ' + '      ' + 'Watch directory.' + '\t\t\t' + '[boolean]\r', '    -h, --help\t\t      ' + 'Show help.' + '\t\t\t' + '[boolean]\r', '\t--run \t\t      ' + 'Save and run file.' + '\t\t' + '[boolean]\r', '\t--env\t\t      ' + 'Node env directive.' + '\t\t' + '[boolean]\r', '\t--file\t\t      ' + 'File to compile.' + '\t\t\t' + '[string]\r', '\t--out\t\t      ' + 'Output file.' + '\t\t\t' + '[string]\r', '\t--js\t\t      ' + 'Parse JS.' + '\t\t\t' + '[boolean]\r'];
        this.usage = "\nUsage:\n* bsc --from <file_name> --to <file_name>";
        this.options = require("yargs").usage(this.usage).option("w", ({
            "alias": "watch",
            "describe": "Watch directory.",
            "type": "boolean",
            demandOption: false,
        })).option("file", ({
            "alias": "file",
            "describe": "File to compile from.",
            "type": "string",
            demandOption: false,
        })).option("out", ({
            "alias": "out",
            "describe": "Output file.",
            "type": "string",
            demandOption: false,
        })).option("run", ({
            "alias": "run",
            "describe": "Run file.",
            "type": "boolean",
            demandOption: false,
        })).option("args", ({
            "alias": "args",
            "describe": "Node arguments",
            "type": "string",
            demandOption: false,
        })).option("js", ({
            "alias": "js",
            "describe": "Parse and print as JS",
            "type": "boolean",
            demandOption: false,
        })).alias('env', 'e').alias('file', 'f').alias('out', 'o').alias('run', 'r').alias("help", "h").alias("version", "v").help(true).argv;
    }
    initGlobals() {
        global.internalPaths = ({
            "utils": './bin/utils.js',
            "ast_to_js": '../lib/compiler/ast_to_js.js',
            "text_to_ast": './text_to_ast.js',
            "compiler": '../lib/compiler/index.js',
            "built_in": './built_in.js',
            "built_in_from_utils": '../lib/compiler/built_in.js',
            "grammar": './lib/grammar',
            "bin": '../../bin/',
            "nearley": '../../nearley/lib/nearley.js',
            "nearleyCompile": "../../nearley/lib/compile.js",
            "nearleyGenerate": "../../nearley/lib/generate.js",
            "nearleyGrammar": "../../nearley/lib/nearley-language-bootstrapped.js",
        });
        global.development = require('./package.json').isDevelopment;
        global.extension = '.js';
        global.baseUrl = ({
            path: path_applied.replace(/\\/g, '/'),
            from_indexJS: true,
            "relative": '',
            "ext": '',
        });
        global.pathJS = (function(pathString = '') {
            const args = Array.from(arguments);
            var r = /\\/g;
            return ({
                resolve: pathLib.resolve(pathString),
                path: pathString.replace(r, '/'),
                dir: pathLib.dirname(pathString).replace(r, '/'),
                name: pathLib.basename(pathString).replace(r, '/'),
                ext: pathLib.extname(pathString).replace(r, '/'),
                filename: ((function(str) {
                    const args = Array.from(arguments);
                    return str.split('\\').join('/').split('/').pop();
                }))(pathString),
                add(...args) {
                    return pathLib.join(pathString, ...args).replace(r, '/');
                },
                relative() {
                    return pathJS(baseUrl.path).add(baseUrl.relative);
                },
                full() {
                    return pathJS(baseUrl.path).add(baseUrl.relative, baseUrl.filename);
                },
            });
        });
        return this;
    }
    showCommands() {
        console.log(this.usage);
        for (let i = 0; i < this.commands.length; i++) {}
    }
    getUtils() {
        this.utils = require(internalPaths.utils);
        this._export = this.utils;
        return this;
    }
    checkForOptions() {
        let options = this.options;
        if (options.help || !options.file) {
            this.showCommands();
            if (!this.options._) {
                process.exit(0);
            }
        } else if (options.version) {
            console.log(require('./package.json').version);
            process.exit(0);
        }
        if (!options.args) {
            options.args = '';
        }
        global.CLIArguments = options._.concat(options.args.split(' '));
        if (!options.out && !options.run && !options.watch) {
            if (options.file.endsWith(".bs") || options.file.endsWith(".bm")) {
                options.out = options.file.slice(0, -3) + ".js";
            } else {
                throw new Error("Input file must be a .bs or .bm file.");
            }
        } else if (options.out) {
            if (!options.out.endsWith(".js")) {
                console.error("Output file must be a .js file.");
                process.exit();
            }
        }
        return this;
    }
    checkIfExists() {
        let dir = pathJS(path_applied).add(this.options.file);
        this.dir = dir;
        baseUrl.filename = pathJS(dir).filename;
        baseUrl.ext = pathJS(dir).ext;
        baseUrl.relative = pathJS(this.options.file).dir;
        if (!fs.existsSync(dir)) {
            console.error(dir);
            console.error(new Error('Provided location doesn\'t exist').message);
            process.exit();
        }
        return this;
    }
    configureOptions() {
        let {
            utils,
            options,
            dir
        } = this;
        let arg0 = '';
        if (options.js) {
            this.export = utils.fromString(dir, arg0, '', true, false, options.out, CLIArguments, options.env);
        } else if (options.run) {
            utils.parse(dir, arg0, '', false, true, options.out, CLIArguments, options.env);
        } else if (!options.watch) {
            baseUrl.filename = options.file;
            utils.parse(dir, arg0, '', false, false, options.out, CLIArguments, options.env);
        }
        return this;
    }
    handleWatch() {
        if (!this.options.watch) return this;
        const exec = require("child_process").execSync;

        function execute(command) {
            const args = Array.from(arguments);
            exec(command, (function(error, stdout, stderr) {
                const args = Array.from(arguments);
                if (error) {
                    console.log(`error: ${error.message}`);
                    return null;
                }
                if (stderr) {
                    console.log(`stderr: ${stderr}`);
                    return null;
                }
                if (stdout) {
                    console.log(`stdout: ${stdout}`);
                }
            }));
        };
        let lastChange = 0;
        let lastFile = '';
        let actionDone = ({});
        fs.watch(path_applied, ({
            recursive: true,
        }), (function(event, path) {
            const args = Array.from(arguments);
            if (event != 'change') {
                return null;
            }
            if (!/\.b(s|m)$/i.test(path)) {
                return null;
            }
            if (path == lastFile && lastChange + 30 > Date.now()) {
                return null;
            }
            var stats = fs.statSync(path);
            var mtime = +stats.mtimeMs;
            if (actionDone[path] | 0 == mtime | 0) {
                return void(setTimeout((function() {
                    const args = Array.from(arguments);
                    delete actionDone[path];
                }), 30));
            }
            actionDone[path] = mtime | 0;
            lastChange = Date.now();
            lastFile = path;
            baseUrl.relative = pathJS(path).dir;
            baseUrl.ext = pathJS(path).ext;
            baseUrl.filename = pathJS(path).filename;
            console.clear();
            execute(`bsc -f=${options.file} -o=${options.out} ${options._.join(' ')}`);
            baseUrl.relative = '';
            baseUrl.ext = '';
            baseUrl.filename = '';
        }));
        return this;
    }
    export () {
        return this._export;
    }
}
module.exports = new CLI().checkForOptions().initGlobals().getUtils().checkIfExists().configureOptions().handleWatch().export();