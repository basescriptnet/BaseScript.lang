(function(k,g){"object"===typeof module&&module.exports?module.exports=g(require("./nearley.js")):k.generate=g(k.nearley)})(this,function(k){function g(a,b,c){null==c&&(c="");return"[\n    "+a.map(function(e){var f='{"name": '+JSON.stringify(e.name);f+=', "symbols": ['+e.symbols.map(n).join(", ")+"]";e.postprocess&&(e.postprocess.builtin&&(e.postprocess=b[e.postprocess.builtin]),f+=', "postprocess": '+l(m(e.postprocess),"        ",{indentFirst:!1}));return f+"}"}).join(",\n    ")+"\n"+c+"]"}function m(a){a=
a.toString().split(/\n/);if(1===a.length)return[a[0].replace(/^\s+|\s+$/g,"")];for(var b=null,c=a.slice(1),e=0;e<c.length;e++){var f=/^\s*/.exec(c[e]);f&&f[0].length!==c[e].length&&(null===b||f[0].length<b.length)&&(b=f[0])}return null===b?a:a.map(function(h){return h.slice(0,b.length)===b?h.slice(b.length):h})}function l(a,b,c){a=Array.isArray(a)?a:a.toString().split("\n");c=c||{};return a.map(function(e,f){var h=!0;0!=f||c.indentFirst||(h=!1);return h?b+e:e}).join("\n")}function n(a){return a instanceof
RegExp?a.toString():a.token?a.token:JSON.stringify(a)}var d=function(a,b){a.config.preprocessor||(a.config.preprocessor="_default");if(!d[a.config.preprocessor])throw Error("No such preprocessor: "+a.config.preprocessor);return d[a.config.preprocessor](a,b)};d.js=d._default=d.javascript=function(a,b){var c="// Generated automatically by nearley, version "+a.version+"\n";c=c+"// http://github.com/Hardmath123/nearley\n(function () {\nfunction id(x) { return x[0]; }\n"+a.body.join("\n");c=c+"var grammar = {\n    Lexer: "+
(a.config.lexer+",\n");c+="    ParserRules: "+g(a.rules,d.javascript.builtinPostprocessors)+"\n";c+="  , ParserStart: "+JSON.stringify(a.start)+"\n";return c=c+"}\nif (typeof module !== 'undefined'&& typeof module.exports !== 'undefined') {\n   module.exports = grammar;\n} else {\n   window."+(b+" = grammar;\n}\n})();\n")};d.javascript.builtinPostprocessors={joiner:"function joiner(d) {return d.join('');}",arrconcat:"function arrconcat(d) {return [d[0]].concat(d[1]);}",arrpush:"function arrpush(d) {return d[0].concat([d[1]]);}",
nuller:"function(d) {return null;}",id:"id"};d.module=d.esmodule=function(a,b){b="// Generated automatically by nearley, version "+a.version+"\n";b=b+"// http://github.com/Hardmath123/nearley\nfunction id(x) { return x[0]; }\n"+a.body.join("\n");b+="let Lexer = "+a.config.lexer+";\n";b+="let ParserRules = "+g(a.rules,d.javascript.builtinPostprocessors)+";\n";b+="let ParserStart = "+JSON.stringify(a.start)+";\n";return b+"export default { Lexer, ParserRules, ParserStart };\n"};d.cs=d.coffee=d.coffeescript=
function(a,b){var c="# Generated automatically by nearley, version "+a.version+"\n";c=c+"# http://github.com/Hardmath123/nearley\ndo ->\n  id = (d) -> d[0]\n"+(l(m(a.body.join("\n")),"  ")+"\n");c=c+"  grammar = {\n    Lexer: "+(a.config.lexer+",\n");c+="    ParserRules: "+l(g(a.rules,d.coffeescript.builtinPostprocessors),"      ",{indentFirst:!1})+",\n";c+="    ParserStart: "+JSON.stringify(a.start)+"\n";return c+"  }\n  if typeof module != 'undefined' && typeof module.exports != 'undefined'\n    module.exports = grammar;\n  else\n    window."+
(b+" = grammar;\n")};d.coffeescript.builtinPostprocessors={joiner:"(d) -> d.join('')",arrconcat:"(d) -> [d[0]].concat(d[1])",arrpush:"(d) -> d[0].concat([d[1]])",nuller:"() -> null",id:"id"};d.ts=d.typescript=function(a,b){b="// Generated automatically by nearley, version "+a.version+"\n";b=b+"// http://github.com/Hardmath123/nearley\n// Bypasses TS6133. Allow declared but unused functions.\n// @ts-ignore\nfunction id(d: any[]): any { return d[0]; }\n"+a.customTokens.map(function(c){return"declare var "+
c+": any;\n"}).join("");b+=a.body.join("\n");b=b+"\ninterface NearleyToken {\n  value: any;\n  [key: string]: any;\n};\n\ninterface NearleyLexer {\n  reset: (chunk: string, info: any) => void;\n  next: () => NearleyToken | undefined;\n  save: () => any;\n  formatError: (token: never) => string;\n  has: (tokenType: string) => boolean;\n};\n\ninterface NearleyRule {\n  name: string;\n  symbols: NearleySymbol[];\n  postprocess?: (d: any[], loc?: number, reject?: {}) => any;\n};\n\ntype NearleySymbol = string | { literal: any } | { test: (token: any) => boolean };\n\ninterface Grammar {\n  Lexer: NearleyLexer | undefined;\n  ParserRules: NearleyRule[];\n  ParserStart: string;\n};\n\nconst grammar: Grammar = {\n  Lexer: "+
(a.config.lexer+",\n");b+="  ParserRules: "+g(a.rules,d.typescript.builtinPostprocessors,"  ")+",\n";b+="  ParserStart: "+JSON.stringify(a.start)+",\n";return b+"};\n\nexport default grammar;\n"};d.typescript.builtinPostprocessors={joiner:"(d) => d.join('')",arrconcat:"(d) => [d[0]].concat(d[1])",arrpush:"(d) => d[0].concat([d[1]])",nuller:"() => null",id:"id"};return d});
